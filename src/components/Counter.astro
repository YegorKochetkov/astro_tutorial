---
import { counterState as counter } from "../scripts/countStore.js";
const buttonPadding = `${counter.val}rem`;
---

<style is:global define:vars={{ buttonPadding }}>
	.counter {
		display: flex;
		flex-direction: row;
		justify-content: left;
		align-items: center;
		gap: 0.5rem;

		font-size: 1.5rem;

		& button {
			padding: var(--buttonPadding);
		}
		&[inert] {
			opacity: 0.5;
		}
	}

	.counter-display {
		position: relative;
		display: inline-flex;
		align-items: center;
		height: 1.5em;
		overflow: hidden;
	}

	.counter-number {
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		transition: transform 0.3s ease-in-out;
		will-change: transform;
		white-space: nowrap;
	}

	.counter-number.slide-out-up {
		transform: translateY(-150%);
	}

	.counter-number.slide-in-from-down {
		transform: translateY(50%);
	}

	.counter-number.slide-out-down {
		transform: translateY(50%);
	}

	.counter-number.slide-in-from-up {
		transform: translateY(-150%);
	}

	.counter-number.visible {
		transform: translateY(-50%);
	}

	.counter-emoji {
		position: relative;
		margin-right: 0.25rem;
		z-index: 1;
	}

	.counter-number-container {
		--containerWidth: 1ch;
		position: relative;
		display: inline-block;
		min-width: var(--containerWidth);
		height: 1.5em;
		line-height: 1.5em;
		transition: width 0.2s ease-in-out;
		will-change: width;
	}
</style>

<div id="counterFallback" class="counter" inert>
	â¤ï¸ {counter.val}
	<button>ğŸ‘</button>
	<button>ğŸ‘</button>
</div>

<script>
	import van from "../scripts/van-1.5.0.min.js";
	import { counterState as counter } from "../scripts/countStore.js";

	const { button, div, span } = van.tags;

	let displayedNumber = counter.val;
	let numberContainer: HTMLElement | null = null;
	let isAnimating = false;
	let animationQueue: { value: number; direction: "up" | "down" }[] = [];

	const padding = van.derive(() => {
		if (counter.val > 3) {
			return 3;
		}

		if (counter.val < 1) {
			return 1;
		}

		return counter.val;
	});

	const updateContainerWidth = (value: number) => {
		if (numberContainer) {
			const digits = Math.abs(value).toString().length + (value < 0 ? 1 : 0);
			numberContainer.style.width = `${digits}ch`;
		}
	};

	function updateContainerWidthBeforeDigitAnimation(value: number, nextValue: number) {
		const currentDigitLength = String(value).length;
		const nextDigitLength = String(nextValue).length;
		const needMoreSpaceForNewDigit = nextDigitLength >= currentDigitLength;
		needMoreSpaceForNewDigit && updateContainerWidth(nextValue);
	}

	const processAnimationQueue = () => {
		if (isAnimating || animationQueue.length === 0 || !numberContainer) {
			return;
		}

		const { value: newValue, direction } = animationQueue.shift()!;

		if (newValue === displayedNumber) {
			processAnimationQueue();
			return;
		}

		updateContainerWidthBeforeDigitAnimation(displayedNumber, newValue);
		isAnimating = true;
		displayedNumber = newValue;

		const oldNumberElement = numberContainer.querySelector(".counter-number.visible");

		if (!oldNumberElement) {
			isAnimating = false;
			processAnimationQueue();
			return;
		}

		const slideOutClass = direction === "up" ? "slide-out-up" : "slide-out-down";
		const slideInClass = direction === "up" ? "slide-in-from-down" : "slide-in-from-up";

		const newNumberElement = span({ class: `counter-number ${slideInClass}` }, newValue.toString());

		numberContainer.appendChild(newNumberElement);

		requestAnimationFrame(() => {
			oldNumberElement.classList.remove("visible");
			oldNumberElement.classList.add(slideOutClass);

			requestAnimationFrame(() => {
				newNumberElement.classList.remove(slideInClass);
				newNumberElement.classList.add("visible");
			});
		});

		setTimeout(() => {
			if (oldNumberElement && oldNumberElement.parentElement) {
				oldNumberElement.parentElement.removeChild(oldNumberElement);
			}
			
			updateContainerWidth(counter.val);
			isAnimating = false;
			processAnimationQueue();
		}, 300);
	};

	const queueNumberChange = (newValue: number) => {
		const direction = newValue > displayedNumber ? "up" : "down";

		if (animationQueue.length > 0) {
			const lastQueuedValue = animationQueue[animationQueue.length - 1].value;
			const finalDirection = newValue > lastQueuedValue ? "up" : "down";
			animationQueue[animationQueue.length - 1] = {
				value: newValue,
				direction: finalDirection,
			};
		} else {
			animationQueue.push({ value: newValue, direction });
		}

		processAnimationQueue();
	};

	const Counter = () => {
		const numberContainerElement = div({ class: "counter-number-container" }, span({ class: "counter-number visible" }, counter.val.toString()));

		const counterDisplay = div({ class: "counter-display" }, span({ class: "counter-emoji" }, "â¤ï¸"), numberContainerElement);

		setTimeout(() => {
			numberContainer = numberContainerElement;
			updateContainerWidth(counter.val);
		}, 0);

		return div(
			{ class: "counter" },
			counterDisplay,
			button(
				{
					onclick: () => {
						counter.val++;
						queueNumberChange(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ‘"
			),
			button(
				{
					onclick: () => {
						counter.val--;
						queueNumberChange(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ‘"
			),
			button(
				{
					onclick: () => {
						counter.val = 0;
						queueNumberChange(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ”„"
			)
		);
	};

	document.addEventListener("astro:page-load", () => {
		document.querySelector("#counterFallback")!.replaceWith(Counter());
	});
</script>
