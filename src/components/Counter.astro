---
import { counterState as counter } from "../scripts/countStore.js";
const buttonPadding = `${counter.val}rem`;
---

<style is:global define:vars={{ buttonPadding }}>
	.counter {
		display: flex;
		flex-direction: row;
		justify-content: left;
		align-items: center;
		gap: 0.5rem;

		font-size: 1.5rem;

		& button {
			padding: var(--buttonPadding);
		}
		&[inert] {
			opacity: 0.5;
		}
	}

	.counter-display {
		position: relative;
		display: inline-flex;
		align-items: center;
		height: 1.5em;
		overflow: hidden;
	}

	.counter-number {
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		transition: transform 0.3s ease-in-out;
		will-change: transform;
		white-space: nowrap;
	}

	.counter-number.slide-out-up {
		transform: translateY(-150%);
	}

	.counter-number.slide-in-from-down {
		transform: translateY(50%);
	}

	.counter-number.slide-out-down {
		transform: translateY(50%);
	}

	.counter-number.slide-in-from-up {
		transform: translateY(-150%);
	}

	.counter-number.visible {
		transform: translateY(-50%);
	}

	.counter-emoji {
		position: relative;
		margin-right: 0.25rem;
		z-index: 1;
	}

	.counter-number-container {
		--containerWidth: 1ch;
		position: relative;
		display: inline-block;
		min-width: var(--containerWidth);
		height: 1.5em;
		line-height: 1.5em;
		transition: width 0.2s ease-in-out;
		will-change: width;
	}
</style>

<div id="counterFallback" class="counter" inert>
	â¤ï¸ {counter.val}
	<button>ğŸ‘</button>
	<button>ğŸ‘</button>
</div>

<script>
	import van from "../scripts/van-1.5.0.min.js";
	import { counterState as counter } from "../scripts/countStore.js";

	const { button, div, span } = van.tags;

	let displayedNumber = counter.val;
	let numberContainer: HTMLElement | null = null;
	let isAnimating = false;
	let animationQueue: { value: number; direction: "up" | "down" }[] = [];

	const padding = van.derive(() => {
		if (counter.val > 3) {
			return 3;
		}

		if (counter.val < 1) {
			return 1;
		}

		return counter.val;
	});

	// Helper to calculate width in characters
	const calculateWidth = (val: number): string => {
		const digits = Math.abs(val).toString().length + (val < 0 ? 1 : 0);
		return `${digits}ch`;
	};

	const setContainerWidth = (value: number) => {
		if (numberContainer) {
			const digits = Math.abs(value).toString().length + (value < 0 ? 1 : 0);
			numberContainer.style.width = calculateWidth(value);
		}
	};

	function setContainerWidthBeforeAnimation(value: number, nextValue: number) {
		const currentWidth = calculateWidth(value);
		const nextWidth = calculateWidth(nextValue);

		// Expand immediately if next value is wider
		if (nextWidth > currentWidth) {
			setContainerWidth(nextValue);
		}
	}

	const processAnimationQueue = () => {
		if (isAnimating || animationQueue.length === 0 || !numberContainer) {
			return;
		}

		const { value: newValue, direction } = animationQueue.shift()!;

		if (newValue === displayedNumber) {
			return;
		}

		setContainerWidthBeforeAnimation(displayedNumber, newValue);
		isAnimating = true;
		displayedNumber = newValue;

		const oldNumberElement = numberContainer.querySelector(".counter-number.visible");

		if (!oldNumberElement) {
			isAnimating = false;
			processAnimationQueue();
			return;
		}

		// Determine animation classes
		const isUp = direction === "up";
		const slideOutClass = isUp ? "slide-out-up" : "slide-out-down";
		const slideInClass = isUp ? "slide-in-from-down" : "slide-in-from-up";

		const newNumberElement = span({ class: `counter-number ${slideInClass}` }, newValue.toString());

		numberContainer.appendChild(newNumberElement);

		requestAnimationFrame(() => {
			requestAnimationFrame(() => {
				oldNumberElement.classList.replace("visible", slideOutClass);
				newNumberElement.classList.replace(slideInClass, "visible");
			});
		});

		setTimeout(() => {
			if (oldNumberElement && oldNumberElement.parentElement) {
				oldNumberElement.parentElement.removeChild(oldNumberElement);
			}
			
			setContainerWidth(counter.val);
			isAnimating = false;
			processAnimationQueue();
		}, 300);
	};

	const enqueueUpdate = (newValue: number) => {
		const direction = newValue > displayedNumber ? "up" : "down";

		// If queue is empty, simply add the new value
		if (animationQueue.length === 0) {
			animationQueue.push({ value: newValue, direction });
		} else {
			// Update the last queued item instead of stacking
			// This acts as a debounce/throttle for rapid updates
			const lastItem = animationQueue[animationQueue.length - 1];
			if (newValue !== lastItem.value) {
				const finalDirection = newValue > lastItem.value ? "up" : "down";
				animationQueue[animationQueue.length - 1] = {
					value: newValue,
					direction: finalDirection,
				};
			}
		}

		processAnimationQueue();
	};

	const Counter = () => {
		const numberContainerElement = div(
			{ class: "counter-number-container" }, 
			span(
				{ class: "counter-number visible" }, 
				counter.val.toString()
			)
		);

		const counterDisplay = div(
			{ class: "counter-display" }, 
			span(
				{ class: "counter-emoji" }, "â¤ï¸"
			), 
			numberContainerElement
		);

		setTimeout(() => {
			numberContainer = numberContainerElement;
			setContainerWidth(counter.val);
		}, 0);

		return div(
			{ class: "counter" },
			counterDisplay,
			button(
				{
					onclick: () => {
						counter.val++;
						enqueueUpdate(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ‘"
			),
			button(
				{
					onclick: () => {
						counter.val--;
						enqueueUpdate(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ‘"
			),
			button(
				{
					onclick: () => {
						counter.val = 0;
						enqueueUpdate(counter.val);
					},
					style: () => `--buttonPadding: ${padding.val}rem`,
				},
				"ğŸ”„"
			)
		);
	};

	document.addEventListener("astro:page-load", () => {
		document.querySelector("#counterFallback")!.replaceWith(Counter());
	});
</script>
